<?php

/**
 * Locomotive
 *
 * Copyright (c) 2015 Joshua Smith
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @package  Locomotive
 */

namespace Locomotive;

use Carbon\Carbon;
use Illuminate\Database\Capsule\Manager as Capsule;
use Illuminate\Support\Collection;
use League\Event\Emitter;
use Locomotive\Database\Models\LocalQueue;
use Locomotive\Database\Models\Metrics;
use Monolog\Logger;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Exception\IOException;
use Symfony\Component\Filesystem\Exception\IOExceptionInterface;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Finder\Finder;
use Symfony\Component\Finder\SplFileInfo;

class Locomotive
{
    /**
     * @var InputInterface
     **/
    protected $input;

    /**
     * @var OutputInterface
     **/
    protected $output;

    /**
     * @var Logger
     **/
    protected $logger;

    /**
     * @var Emitter
     */
    protected $emitter;

    /**
     * @var Capsule
     **/
    protected $DB;

    /**
     * @var Lftp
     **/
    public $lftp;

    /**
     * @var resource
     **/
    protected $sshSession;

    /**
     * Datetime of last run.
     *
     * @var String
     **/
    public $lastRun;

    /**
     * A unique run ID.
     *
     * @var String
     **/
    public $runId;

    /**
     * Whether or not lftp has a background proc running.
     *
     * @var Bool
     **/
    public $isLftpBackgrounded;

    /**
     * The process ID of the lftp terminal attachment.
     *
     * @var Int
     **/
    public $lftpTerminalId;

    /**
     * Current count of items in lftp queue.
     *
     * @var Int
     **/
    public $lftpQueueCount;

    /**
     * Current mapping of active lftp queue items to known local DB
     * queue items.
     *
     * @var Collection
     **/
    public $mappedQueue;

    /**
     * Newly initiated transfers.
     *
     * @var Collection
     **/
    public $newTransfers;

    /**
     * Newly moved finished items.
     *
     * @var Collection
     **/
    public $movedItems;

    /**
     * @var array
     **/
    protected $arguments = array();

    /**
     * @var array
     **/
    protected $options = array();

    /**
     * Locomotive Constructor.
     *
     * @param InputInterface $input An Input instance
     * @param OutputInterface $output An Output instance
     * @param array $config Configuration options generated by Locomotive\Configurator
     * @param Logger $logger Monolog Logger
     * @param Emitter $emitter League\Event
     * @param \Illuminate\Database\Capsule\Manager $DB
     *
     * @throws \Symfony\Component\Console\Exception\InvalidArgumentException
     */
    public function __construct(
        InputInterface $input,
        OutputInterface $output,
        array $config,
        Logger $logger,
        Emitter $emitter,
        Capsule $DB
    ) {
        $this->input = $input;
        $this->output = $output;
        $this->options = $config;
        $this->logger = $logger;
        $this->emitter = $emitter;
        $this->DB = $DB;

        // initial Locomotive setup, checks, and validation
        $this->arguments['host'] = $input->getArgument('host');
    }

    /**
     * Bootstrap Locomotive.
     *
     * @return Locomotive
     **/
    public function bootstrap()
    {
        // grab last run time and update it
        $now = Carbon::now();
        $metrics = Metrics::firstOrNew(['id' => 1]);
        $this->lastRun = isset($metrics->last_run) ? Carbon::parse($metrics->last_run) : $now;
        $metrics->last_run = $now->toDateTimeString();
        $metrics->save();

        $this->runId = uniqid('', true);
        $this->mappedQueue = new Collection;
        $this->movedItems = new Collection;

        // setting working directory
        if (null === $this->options['working-dir']) {
            $this->options['working-dir'] = BASEPATH . '/app/storage/working/';
        } else {
            $this->options['working-dir'] = rtrim($this->options['working-dir'], '/') . '/';
        }

        // setting up lftp command builder
        $this->lftp = new Lftp(
            array_merge($this->arguments, $this->options),
            $this->logger
        );

        // setup ssh/sftp session
        $this->createSshSession();

        return $this;
    }

    /**
     * Checks for any missing system dependencies. For now, that's just `lftp`.
     *
     * @return mixed
     **/
    public function dependencyCheck()
    {
        // check for lFTP
        if (!`which lftp`) {
            $this->logger->critical(
                "LFTP is either not installed on this system, or not in the path.\n"
                . "Please provide the path in the Locomotive config or find out\n"
                . 'more about LFTP by visiting: https://github.com/lavv17/lftp'
            );

            return 0;
        }

        return $this;
    }

    /**
     * Sets the class' paths or path lists.
     *
     * @return Locomotive
     *
     * @throws \Symfony\Component\Console\Exception\InvalidArgumentException
     **/
    public function setPaths()
    {
        // attempt to set source/target from config file if not provided at CLI
        if (!array_filter([
                $this->input->getArgument('source'),
                $this->input->getArgument('target'),
            ])
        ) {
            $this->arguments['source'] = array_keys($this->options['source-target-map']);
            $this->arguments['target'] = array_values($this->options['source-target-map']);
            // setting SOURCE to either single path or list
        } else {
            $sourceArg = $this->input->getArgument('source');
            $this->arguments['source'] = str_contains($sourceArg, ':')
                ? explode(':', $sourceArg)
                : $sourceArg;

            // setting TARGET to either single path or list
            $targetArg = $this->input->getArgument('target');
            $this->arguments['target'] = str_contains($targetArg, ':')
                ? explode(':', $targetArg)
                : $targetArg;
        }

        return $this;
    }

    /**
     * Validates the provided path schema.
     *
     * @return Locomotive
     **/
    public function validatePaths()
    {
        // validating list matching for source/target mapping purposes
        if (is_array($this->arguments['target']) && is_array($this->arguments['source'])) {
            if (count($this->arguments['source']) !== count($this->arguments['target'])) {
                $this->logger->error('When both the SOURCE and TARGET are path lists, they are assumed to be mapped and their number of paths must match.');

                exit(1);
            }
        } elseif (is_array($this->arguments['target']) && !is_array($this->arguments['source'])) {
            $this->logger->error('The provided TARGET is a list of paths, but the SOURCE is not. I don\'t know what to do.');

            exit(1);
        } elseif (null !== $this->arguments['source'] && null === $this->arguments['target']) {
            $this->logger->error('If the SOURCE arguement is used at the CLI, then the TARGET must be provided at the CLI as well.');

            exit(1);
        }

        // validating source-target maps from config file
        if (
            !$this->options['source-target-map']
            && !array_filter([$this->arguments['source'], $this->arguments['target']])
        ) {
            $this->logger->error('Both SOURCE and TARGET arguemnts are missing.');

            exit(1);
        }

        return $this;
    }

    /**
     * Gets a source path's mapped target path, or return the target path if no
     * mapping is specified.
     *
     * @param string $sourceDir The source directory to search for a mapped target
     *
     * @return string A mapped target path
     **/
    private function mapTargetFromSource($sourceDir)
    {
        if (is_array($this->arguments['target']) && is_array($this->arguments['source'])) {
            // get the key for the matching array source
            $matchingSource = array_filter($this->arguments['source'], function ($source) use ($sourceDir) {
                return str_contains($source, rtrim($sourceDir, '/'));
            }, ARRAY_FILTER_USE_BOTH);

            // return the target path at the key matching the source, effectively
            // mapping them together
            return $this->arguments['target'][key($matchingSource)];
        } else {
            return $this->arguments['target'];
        }
    }

    /**
     * Gets the status of the lftp queue.
     *
     * @return array The response from `lftp queue`
     **/
    public function getLftpStatus()
    {
        $this->logger->debug('Checking lftp status via queue attachment attempt.');

        $status = $this->lftp->addCommand('queue')
                             ->execute(false, true);

        // test for background-ed process
        if (strpos(end($status), 'backgrounded') !== false) {
            $this->logger->debug('It appears that lftp is NOT background-ed.');

            $this->isLftpBackgrounded = false;
        } else {
            $this->logger->debug('It appears that lftp IS background-ed.');

            $this->isLftpBackgrounded = true;
        }

        return $status;
    }

    /**
     * Parses the raw output from the lftp queue. Builds a queue mapping for
     * lftp and local items, and sets important class variables like the lftp
     * queue count.
     *
     * @param array $queueOutput The raw lftp queue terminal output.
     *
     * @return Locomotive
     **/
    public function parseLftpQueue(array $queueOutput)
    {
        $this->logger->debug('An active lftp queue was found. Begin parsing.');

        // use Illuminate\Collection to ease the pain
        $lftpQueue = Collection::make($queueOutput);
        $lftpQueue->pop();

        // parse terminal ID out of lftp queue output
        preg_match("/(\\[\\d+\\]).+/", $lftpQueue->first(), $matches);
        $this->lftpTerminalId = trim($matches[1], '[]');
        $this->logger->debug("Setting the lftp terminal attachment ID to $this->lftpTerminalId.");

        // seek to beginning of active items
        $activeKey = $lftpQueue->search(function ($item) {
            return str_contains($item, 'Now executing:');
        });

        // seek to beginning of queued items
        $queuedKey = $lftpQueue->search(function ($item) {
            return str_contains($item, 'Commands queued:');
        });

        // seperate items into new collections
        if ($queuedKey !== false) {
            $activeItems = $lftpQueue->slice($activeKey, $queuedKey - $activeKey);
            $queuedItems = $lftpQueue->slice($queuedKey + 1);
        } else {
            $activeItems = $lftpQueue->slice($activeKey);
            $queuedItems = null;
        }

        // setting items to empty Collections if needed
        $activeItems = ($activeItems instanceof Collection) ? $activeItems : new Collection;
        $queuedItems = ($queuedItems instanceof Collection) ? $queuedItems : new Collection;

        // clean active items
        $activeItems->transform(function ($item, $key) {
            if ($key === 0) {
                return substr($item, 15);
            } else {
                return ltrim($item, "\t-");
            }
        });

        // clean queued items
        $queuedItems->transform(function ($item) {
            return ltrim($item);
        });

        // create a merged list of all lftp queue items
        $mergedLftpQueue = $activeItems->merge($queuedItems);

        // get all unfinished items from local DB queue
        $localQueue = LocalQueue::notFinished()->get();

        // map lftp queue items to local DB queue items
        $localQueue->each(function ($localItem) use ($mergedLftpQueue) {
            $mappedItem = $mergedLftpQueue->search(function ($aItem) use ($localItem) {
                return str_contains($aItem, $localItem->name);
            });

            if ($mappedItem !== false) {
                $this->mappedQueue->put($localItem->id, $mappedItem);
            }
        });

        // set class variable with count of current active items
        $this->lftpQueueCount = $this->mappedQueue->count();
        $this->logger->debug("Recording the lftp queue count as $this->lftpQueueCount");

        // TODO: parse stats
        /*$parsedQueue = array();
        foreach ($mappedQueue as $queueId => $item) {
            preg_match('/(\[\d+\]) (pget -c|mirror -c).+? -- (\d+?[a-zA-Z]\/\d+?[a-zA-Z]) (\(\d+?%\))/', $item, $matches);

            $parsedQueue[$queueId] = [
                'id' => $queueId,
                'lftpQueueEntry' => $item,
                'parseTest' => $matches,
            ];
        }*/

        return $this;
    }

    /**
     * Updates item flags in the local database queue by comparing item stats
     * such as file size and count.
     *
     * @return Locomotive
     *
     * @throws \InvalidArgumentException
     **/
    public function updateLocalQueue()
    {
        $this->logger->debug('Beginning local DB queue update.');

        if ($this->mappedQueue->count() < 1) {
            // a background-ed lftp queue was never detected; assume it has cleared
            // since last run and check local items
            $localQueue = LocalQueue::notForRun($this->runId)
                                    ->notFinished()
                                    ->notFailed()
                                    ->get();
        } else {
            // get all unfinished items from local DB queue that don't exist
            // in mapped queue (aren't currently active in lftp)
            $localQueue = LocalQueue::notForRun($this->runId)
                                    ->notFinished()
                                    ->notFailed()
                                    ->lftpActive($this->mappedQueue->keys())
                                    ->get();
        }

        // mark items finished if file size matches
        if ($localQueue->count() > 0) {
            $this->logger->debug('Unfinished items found in local queue. Checking for completeness.');

            $localQueue->each(function ($item) {
                // seeking to file location
                $finderItem = new Finder();
                $finderItem->in($this->options['working-dir'])
                           ->name($item->name);
                $finderItem = current(iterator_to_array($finderItem));

                if ($finderItem !== false) {
                    $itemSize = $this->calculateItemSize($finderItem);

                    // check file size and mark as finished
                    if (
                        (int)$item->size_bytes === (int)$itemSize['itemSize']
                        && (int)$item->file_count === (int)$itemSize['fileCount']
                    ) {
                        $item->is_finished = true;
                        $item->is_failed = false;
                        $item->save();
                    } else {
                        // mark item as failed if there is a size or count mismatch
                        $item->is_failed = true;
                        $item->save();

                        $this->logger->warning("The following transfer failed: $item->name");
                    }
                } else {
                    // mark item as failed if it can't be found locally
                    $item->is_failed = true;
                    $item->save();

                    $this->logger->warning("The following transfer failed: $item->name");
                }

                if ( // emit a failure event if we've reached the maximum number of retries
                    (bool)$item->is_failed === true
                    && (int)$item->retries === (int)$this->options['max-retries']
                ) {
                    $this->emitter->emit('event.transferFailed', $item->name);
                }
            });
        }

        return $this;
    }

    /**
     * Records a transfer in the local queue.
     *
     * @param SplFileInfo $item The transfered item
     * @param string $transferPath The absolute transfer path
     *
     * @return LocalQueue The Eloquent model
     *
     * @throws \InvalidArgumentException
     **/
    private function recordItemToQueue($item, $transferPath)
    {
        // get item size
        $itemSize = $this->calculateItemSize($item);

        // create a hash; clean `$transferPath`; get the mapped target for the item
        $hash = $this->makeHash($item->getBasename(), $item->getMTime());
        $transferPath = rtrim($transferPath, '/');
        $target = $this->mapTargetFromSource($transferPath);
        $name = $item->getBasename();

        // write the item to the local DB queue
        $localQueue = LocalQueue::firstOrNew(['hash' => $hash]);

        $localQueue->run_id = $this->runId;
        $localQueue->name = $name;
        $localQueue->host = $this->arguments['host'];
        $localQueue->source_dir = $transferPath;
        $localQueue->size_bytes = $itemSize['itemSize'];
        $localQueue->file_count = $itemSize['fileCount'];
        $localQueue->last_modified = date('Y-m-d H:i:s', $item->getMTime());
        $localQueue->started_at = date('Y-m-d H:i:s');
        $localQueue->target_dir = $target;

        if ((bool)$localQueue->is_failed === true) {
            $localQueue->is_failed = false;
            $localQueue->retries++;
        }

        $localQueue->save();

        return $localQueue;
    }

    /**
     * Initiates transfers based on number of available slots.
     *
     * Handles SSH session setup; source item list retreival, filtering, and
     * zipping; speed limit setting; lftp command issuance; and recording
     * active/new transfers to the local queue.
     *
     * @param int $availableSlots Number of slots available for transfer
     *
     * @return Locomotive
     *
     * @throws \InvalidArgumentException
     **/
    public function initiateTransfers($availableSlots = null)
    {
        if (null === $availableSlots) {
            $lftpQueueCount = $this->lftpQueueCount ?: 0;

            // assume lftp queue is inactive
            $availableSlots = $this->options['transfer-limit'] - $lftpQueueCount;

            if ($availableSlots === 0) {
                $this->logger->info('All transfer slots are full.');

                // no transfers occurred for program output
                $this->newTransfers = false;

                return $this;
            } else {
                $this->logger->debug("Setting available transfer slots to $availableSlots.");
            }
        }

        // get listing of items from all source directories
        $this->logger->debug('Retrieving all available items from host source(s).');
        $sourceItems = $this->getSourceItems();

        // filter source items list of any seen/fetched items
        $this->logger->debug('Applying filters to source items.');
        $sourceItems = $this->filterSourceItems($sourceItems);

        // zip items together into one collection; limit to available slots
        $this->logger->debug('Building the transfer list.');
        $transferList = $this->buildTransferList($sourceItems, $availableSlots);

        // set speed limit before initiating transfers
        $this->lftp->setSpeedLimit($this->options['speed-limit']);

        // issue lftp commands depending on `isDir()` or `isFile()`
        $transferList->each(function ($item) {
            // parse out path to send to lftp
            $transferPath = $item->getPath();
            preg_match('@ssh2.sftp://(.+?)/(.+)@us', $transferPath, $matches);
            $transferPath = "/$matches[2]/";

            if ($item->isDir()) {
                $files = new Finder();
                $files->depth('== 0');

                // constrain search to source directory
                $files->in($item->getPath() . '/' . $item->getBasename());

                if (iterator_count($files) < 8) {
                    // mirror directory using pget
                    $this->lftp->mirrorDir(
                        $transferPath . $item->getBasename(),
                        $this->options['connection-limit'],
                        false,
                        true
                    );
                } else {
                    // mirror using parallel
                    $this->lftp->mirrorDir(
                        $transferPath . $item->getBasename(),
                        false,
                        $this->options['connection-limit'],
                        true
                    );
                }
            } elseif ($item->isFile()) {
                // fetch file using pget
                $this->lftp->pgetFile(
                    $transferPath . $item->getBasename(),
                    $this->options['connection-limit'],
                    true
                );
            }

            // record transfer in local queue
            $this->recordItemToQueue($item, $transferPath);

            // emit `transferStarted` event
            $this->emitter->emit('event.transferStarted', $item->getBasename());
        });

        if (count($transferList) > 0) {
            $this->logger->debug('Recorded new transfers to the local queue.');

            // execute transfer
            $this->lftp->execute(true, $this->isLftpBackgrounded, $this->lftpTerminalId);

            // write transferred items to global variable for output
            $this->newTransfers = $transferList;
        } else {
            $this->logger->info('There are no new items available for transfer.');

            // no transfers occurred for program output
            $this->newTransfers = false;
        }

        return $this;
    }

    /**
     * Moves finished items to their target destination; Marks as moved in the
     * local database queue.
     *
     * @return Locomotive
     **/
    public function moveFinished()
    {
        $this->logger->info('Looking for finished items.');

        // getting finished items that haven't been moved yet
        $finished = LocalQueue::finished()
                              ->notMoved()
                              ->get();

        if ($finished->count() > 0) {
            $this->logger->debug('Finished items were found in the local queue.');
            $workingDir = $this->options['working-dir'];
            $fs = new Filesystem();

            $finished->each(function ($item) use ($workingDir, $fs) {
                // move item
                $targetDir = rtrim($item->target_dir, '/') . '/';

                // check for existence of target directory
                if (!$fs->exists($targetDir)) {
                    $this->logger->error("The target directory could not be found: $targetDir");
                } else {
                    try {
                        $fs->rename($workingDir . $item->name, $targetDir . $item->name);

                        $item->is_moved = true;
                        $item->save();

                        // emit `transferComplete` event
                        $this->emitter->emit('event.transferComplete', $targetDir . $item->name);
                    } catch (IOException $e) {
                        $this->logger->error($e->getMessage());
                    }
                }

                if ($item->is_moved !== true) {
                    $this->logger->error("'$item->name' was NOT moved and is still in the working directory.");
                } else {
                    $this->movedItems->push($item);
                }
            });
        } else {
            $this->logger->debug('No finished items were returned from the local DB queue.');
        }

        return $this;
    }

    /**
     * Removes finished items from source.
     *
     * @return Locomotive
     **/
    public function removeSourceFiles()
    {
        if ($this->options['remove-sources']['remove'] !== true) {
            return $this;
        }

        $this->logger->debug('Beginning source file removal.');

        // getting finished items
        $finished = LocalQueue::finished()
                              ->notFailed()
                              ->where('source_cleaned', false)
                              ->get();

        if ($finished->count() > 0) {
            $fs = new Filesystem();

            // applying source exclusion from config
            if (count($this->options['remove-sources']['exclude']) > 0) {
                $finished = $finished->reject(function ($item) {
                    foreach ($this->options['remove-sources']['exclude'] as $exclusion) {
                        if (str_contains(trim($exclusion, '/'), trim($item->source_dir, '/'))) {
                            return true;
                        }
                    }
                });
            }

            $finished->each(function ($item) use ($fs) {
                $sourceItemPath = rtrim($item->source_dir, '/') . '/' . $item->name;
                $sourceStream = 'ssh2.sftp://' . (int)$this->sshSession . $sourceItemPath;

                // check to make sure item path exists on source as a sort
                // of sanity check to prevent bad things
                if ($fs->exists($sourceStream)) {
                    try {
                        @$fs->remove($sourceStream);

                        $item->source_cleaned = true;
                        $item->save();

                        $this->logger->info("The following item was removed from source: $sourceItemPath");
                    } catch (\Exception $e) {
                        $this->logger->warning($e->getMessage());
                    } catch (IOExceptionInterface $e) {
                        $this->logger->warning($e->getMessage());
                    }
                }

                if ($item->source_cleaned !== true) {
                    $this->logger->warning("There was a problem removing an item: $sourceItemPath");
                }
            });
        }

        return $this;
    }

    /**
     * Gets all unfiltered items from host sources and structures them into
     * tidy collections keyed by source path.
     *
     * @return Collection
     *
     * @throws \InvalidArgumentException
     **/
    private function getSourceItems()
    {
        $sources = $this->arguments['source'];
        $items = new Collection;

        // casting `$sources` to an array to normalize data structure
        if (!is_array($sources)) {
            $sources = array($sources);
        }

        // retrieve all items from sources and build collections
        foreach ($sources as $source) {
            // instantiate a new Finder instance
            $finder = new Finder();
            $hostItems = $finder->depth('== 0');

            // constrain search to source directory
            // TODO: catch exception
            $hostItems->in('ssh2.sftp://' . (int)$this->sshSession . $source)
                      ->ignoreDotFiles(true);

            // collect the source items
            $collectedHostItems = Collection::make(iterator_to_array($hostItems, false));

            // reject items that are still being unpacked
            $collectedHostItems = $collectedHostItems->reject(function ($item) {
                if (starts_with($item->getBasename(), ['_UNPACK_', '_FAILED_'])) {
                    $this->logger->debug("An item was pattern-rejected: {$item->getBasename()}");

                    return true;
                }
            });

            // reject items that do not pass an optional cutoff date
            if (null !== $this->options['newer-than']) {
                $collectedHostItems = $collectedHostItems->reject(function ($item) {
                    if ($item->getMTime() < strtotime($this->options['newer-than'])) {
                        $this->logger->debug("An item was date-cutoff rejected: {$item->getBasename()}");

                        return true;
                    }
                });
            }

            // place source items into main items collection
            $items->put($source, $collectedHostItems);
        }

        return $items;
    }

    /**
     * Filter host source items to remove anything already seen and tracked by
     * the local queue. Attempts to prevent rejection of items sharing the same
     * name by hashing the name with the mod time of the item.
     *
     * @param Collection $items
     *
     * @return Collection
     **/
    private function filterSourceItems($items)
    {
        // first, check if local queue has ANY items at all
        $count = LocalQueue::count();
        if ($count === 0) {
            return $items;
        }

        // retrieve all items from the local queue
        $seen = LocalQueue::pluck('hash');

        // retrieve items that can be retried (and aren't currently active)
        $retry = LocalQueue::canBeRetried($this->options['max-retries'])
                           ->lftpActive($this->mappedQueue->keys())
                           ->pluck('hash');

        // ensures that these are Collections even if only one item is returned from `LocalQueue::pluck()`
        $seen = ($seen instanceof Collection) ? $seen : Collection::make($seen);
        $retry = ($retry instanceof Collection) ? $retry : Collection::make($retry);

        // removing retry-able items
        if ($retry->count() > 0) {
            $seen = $seen->diff($retry);
        }

        $items->transform(function (&$sourceItems) use ($seen) {
            return $sourceItems->reject(function ($item) use ($seen) {
                // filter out items seen in the local queue
                return $seen->contains(
                    $this->makeHash($item->getBasename(), $item->getMTime())
                );
            });
        });

        // filter out sources without any items
        $items = $items->reject(function ($source) {
            return $source->isEmpty();
        });

        return $items;
    }

    /**
     * Builds a final transfer list in FIFO ordering by default.  Also supports
     * 'zipping' together items from multiple sources into an alternating list
     * and limiting to available slots.
     *
     * @param Collection $items A full list of sources/items
     * @param int $slots Available transfer slots
     *
     * @return Collection
     **/
    private function buildTransferList($items, $slots)
    {
        $orderedItems = new Collection;

        // simple reduction to prevent null listings
        $items->map(function ($sourceListing) use ($slots) {
            return $sourceListing->take($slots);
        });

        if ($this->options['zip-sources'] === true) {
            // zip all sources together in alternating fashion
            for ($i = 0; $i <= $slots; $i++) {
                $items->each(function ($sourceListing) use ($orderedItems) {
                    $orderedItems->push($sourceListing->shift());
                });
            }
        } else {
            // build `$orderedItems` list in FIFO order
            $items->each(function ($sourceListing) use ($orderedItems) {
                $sourceListing->each(function ($source) use ($orderedItems) {
                    $orderedItems->push($source);
                });
            });
        }

        return $orderedItems->take($slots)->filter();
    }

    /**
     * Calculates the size and file count of an item.
     *
     * @param SplFileInfo $item
     *
     * @return array Item size and file count
     *
     * @throws \InvalidArgumentException
     **/
    private function calculateItemSize(SplFileInfo $item)
    {
        $itemSize = 0;
        $fileCount = 0;

        // file or dir specific data
        if ($item->isDir()) {
            $files = new Finder();

            // constrain search to source directory
            $files->in($item->getPath() . '/' . $item->getBasename());

            // calculate recursive sums
            foreach ($files as $file) {
                if ($file->isFile()) {
                    $itemSize += $file->getSize();
                    $fileCount++;
                }
            }
        } elseif ($item->isFile()) {
            $itemSize = $item->getSize();
            $fileCount = 1;
        }

        return [
            'itemSize' => $itemSize,
            'fileCount' => $fileCount,
        ];
    }

    /**
     * Creates an MD5 hash for an item to assist with unique identification.
     *
     * @param string $name The item name
     * @param int $modTime Last modified time in unix timestamp format
     *
     * @return string MD5 Hash
     **/
    public function makeHash($name, $modTime)
    {
        $serial = serialize([$name, $modTime]);

        return md5($serial);
    }

    /**
     * A wrapping method to set global lftp limits on the host.
     *
     * Current limits supported: speed, queue items
     *
     * @return Locomotive
     **/
    public function setLimits()
    {
        $this->lftp->setSpeedLimit($this->options['speed-limit'])
                   ->setQueueTransferLimit($this->options['transfer-limit'])
                   ->execute(false, $this->isLftpBackgrounded, $this->lftpTerminalId);

        return $this;
    }

    /**
     * Creates an SSH sFTP connection to the host server.
     *
     * Key file authentication requires both a public and private key. If a public
     * key file was not provided as an option, an attempt will still be made
     * with an assumption about the public key's location and name.
     *
     * @return Locomotive
     **/
    private function createSshSession()
    {
        $connection = ssh2_connect($this->arguments['host'], $this->options['port']);

        if ($this->options['private-keyfile']) {
            // handle connections w/ ssh key file
            $auth = @ssh2_auth_pubkey_file(
                $connection,
                $this->options['username'],
                $this->options['public-keyfile'] ?: $this->options['private-keyfile'] . '.pub',
                $this->options['private-keyfile']
            );
        } else {
            // try with username and password
            $auth = @ssh2_auth_password(
                $connection,
                $this->options['username'],
                $this->options['password']
            );
        }

        // test connection result
        if ($auth === false) {
            $this->logger->error('SSH connection attempt to host failed. Check your authentication settings and try again.');

            exit(1);
        } else {
            $this->sshSession = ssh2_sftp($connection);
            $this->logger->debug('SSH connection attempt succeeded.');
        }

        return $this;
    }

    /**
     * Gets the parsed arguments.
     *
     * @return array
     */
    public function getArguments()
    {
        return $this->arguments;
    }

    /**
     * Gets the parsed options.
     *
     * @return array
     */
    public function getOptions()
    {
        return $this->options;
    }

    /**
     * Gets the console input.
     *
     * @return InputInterface
     */
    public function getInput()
    {
        return $this->input;
    }

    /**
     * Gets the console output.
     *
     * @return OutputInterface
     */
    public function getOutput()
    {
        return $this->output;
    }

    /**
     * Gets the console logger.
     *
     * @return Logger
     */
    public function getLogger()
    {
        return $this->logger;
    }
}
